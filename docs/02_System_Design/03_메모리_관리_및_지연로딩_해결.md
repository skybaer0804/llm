# 03. 메모리 관리 및 지연로딩 해결

64GB 통합 메모리 환경에서 대형 모델을 안정적으로 운영하기 위한 기술적 해결 방안과 메모리 관리 전략을 설명합니다.

## 1. 지연 로딩(Lazy Loading)의 이해와 문제점

Ollama는 기본적으로 요청이 올 때 모델을 메모리에 로드합니다. `qwen3-coder-next:q4_K_M`와 같은 대형 모델(52GB)은 로드하는 데만 수십 초가 소요될 수 있으며, 이는 AutoGen 에이전트 간의 대화 흐름을 끊는 '지연 로딩 문제'를 야기합니다.

### 해결 전략: Pre-loading 및 Keep-alive 설정
- **keep_alive**: 모델이 추론 후 즉시 메모리에서 내려가지 않도록 유지 시간을 설정합니다. (예: `keep_alive=5m`)
- **Pre-loading**: 라우터가 다음 단계의 작업을 미리 감지하여 백그라운드에서 모델 로드를 시작합니다.

## 2. 메모리 반납(Unloading) 로직 구현

64GB 시스템에서 가장 위험한 상황은 설계자(52GB)와 개발자(19GB) 모델이 동시에 메모리에 존재하려 할 때입니다.

### 명시적 언로드 가이드
라우터는 `/api/unload` (또는 `/api/generate` 요청 시 `keep_alive: 0`)를 통해 사용이 끝난 모델의 메모리를 강제로 반납합니다.

```bash
# 특정 모델 즉시 언로드 (Ollama API)
curl http://localhost:11434/api/generate -d '{
  "model": "qwen3-coder-next:q4_K_M",
  "keep_alive": 0
}'
```

## 3. 리소스 우선순위 관리

- **1순위 (Architect)**: 분석 단계에서 모든 리소스를 독점. OS 가용 메모리를 제외한 모든 공간을 할당받습니다.
- **2순위 (Coder/Reviewer)**: 구현/검증 단계에서 협업. 두 모델이 합산 30GB 내외이므로 병렬 로드 상태를 유지하여 빠른 피드백 루프를 형성합니다.

## 4. 모니터링 및 자동 회복

- **메모리 임계치 체크**: 시스템 메모리 점유율이 90%를 초과할 경우, 라우터는 즉시 가장 오래된 모델을 언로드합니다.
- **지연 시간 로깅**: 모델 로딩에 소요되는 시간을 추적하여 `keep_alive` 파라미터를 동적으로 조정하는 참고 자료로 활용합니다.
